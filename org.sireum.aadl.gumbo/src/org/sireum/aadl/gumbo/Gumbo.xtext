grammar org.sireum.aadl.gumbo.Gumbo with org.osate.xtext.aadl2.properties.Properties

generate gumbo "http://www.sireum.org/aadl/gumbo/Gumbo"

import "http://aadl.info/AADL/2.0" as aadl2

import "http://www.eclipse.org/emf/2002/Ecore" as ecore


AnnexLibrary returns aadl2::AnnexLibrary:
	GumboLibrary
;

AnnexSubclause returns aadl2::AnnexSubclause:
	GumboSubclause
;

GumboLibrary returns GumboLibrary:
	{GumboLibrary}
	'library' 'for' 'gumbo'
;

GumboSubclause returns GumboSubclause:
	{GumboSubclause}
//	specs+=SpecSection*
    specs=SpecSection
;

SpecSection:
//	ComputationalModel
//|	Flows
	(state = State)?
	(functions = Functions)?
	(invariants = Invariants)?
	(integration = Integration)?
	(initialize = Initialize)?
	(compute = Compute)?
;

//ComputationalModel:
//	'computational_model' (
//		{PeriodicComputationalModel} 'periodic'
//	|	{HyperperiodComputationalModel} 'hyperperiod' 'with' 
//		(constraints+=[aadl2::NamedElement] ('<' constraints+=[aadl2::NamedElement])* )
//	)
//;

//Flows:
//	'flows' (flows+=Flow)+
//;
//
//Flow returns Flow:
//	=>	flowId=ID ':' 
//		srcPorts+=FeatureElement (',' srcPorts+=FeatureElement)* '-fun->'
//		dstPorts+=FeatureElement (',' dstPorts+=FeatureElement)* 
//;


//Contract:
//	'contracts' (specs+=SpecStatement)+
//;

State:
	'state' (decls += StateVarDecl)+
;

StateVarDecl:
 // ...plain declaration without cross referencing is given below	
 // id1 = ID ':' typeName = ID
 // ...single id per type
 (name = ID ':') typeName=[aadl2::DataSubcomponentType|QCREF] ';'
 // ...multiple ids per type -- leave this out for now until I figure out how to get cross-referencing right for an id list
 // ids+=ID (',' ids+=ID)* ':' typeName=[aadl2::DataSubcomponentType|QCREF] ';'
;

Invariants:
	'invariants' (specs+=InvSpec)+
;

InvSpec:
	'inv' displayName=STRING ':' expr=Expr ';'
;

Integration:
	'integration' (specs+=SpecStatement)+
;

Initialize:
	'initialize' (specs+=InitializeSpecStatement)+
;

InitializeSpecStatement:
  GuaranteeStatement   	
;

Compute:
	'compute' 
	  // for now, just set the grammar to have a collection of case statements.  
	  // Eventually allow arbitrary assume/guarantees around an aggregated case statement
	   (cases+=CaseStatementClause)+
;

CaseStatementClause:
	'case' displayName=STRING ':' 
	       // in case clauses, we must have both an assume clause and a guarantee clause
	       // but they don't have a display name (they will "inherit" the name from the case name).
	       assumeStatement = AnonAssumeStatement
	       guaranteeStatement = AnonGuaranteeStatement
;

SpecStatement:
    AssumeStatement
  | GuaranteeStatement   	
;


AssumeStatement: 
	'assume' displayName=STRING ':' expr=Expr ';'
;

AnonAssumeStatement:  
	'assume' expr=Expr ';'
;

GuaranteeStatement: 
	'guarantee' displayName=STRING ':' expr=Expr ';'
;

AnonGuaranteeStatement: 
	'guarantee' expr=Expr ';'
;


//SpecStatement:
//	{AssumeStatement} 'assume' ('for' forPort=[aadl2::NamedElement])? 
//		assumeTitle=STRING ':' pred=PREDICATE ('tracesTo' '<' tracesTo=ID '>')?  
//|	{GuaranteeStatement} 'guarantee' guaranteeTitle=STRING ':' expr=Expr
//;

PREDICATE: // TODO 
	ID
;

Expr:
	ImpliesExpr
;

ImpliesExpr returns Expr:
	EquivExpr (=>({BinaryExpr.left=current} ('=>'|'implies')) right=ImpliesExpr)?
;

EquivExpr returns Expr:
	OrExpr (=> ({BinaryExpr.left=current} op='<=>') right=OrExpr)?;

OrExpr returns Expr:
	AndExpr (=>({BinaryExpr.left=current} (op='or'|op='orelse')) right=AndExpr)*
;

AndExpr returns Expr:
	RelationalExpr (=>({BinaryExpr.left=current} (op='and'|op='andthen')) right=RelationalExpr)*
;


RelationalOp:
	'<' | '<=' | '>' | '>=' | '=' | '<>'
;
 
RelationalExpr returns Expr:
	AddSubExpr (=>({BinaryExpr.left=current} op=RelationalOp) right=AddSubExpr)?
;

AddSubExpr returns Expr:
	MultDivModExpr (=>({BinaryExpr.left=current} op=('+' | '-')) right=MultDivModExpr)*
;

MultDivModExpr returns Expr:
	ExpExpr (=>({BinaryExpr.left=current} op=('*' | '/' | '%')) right=ExpExpr)*	
;

ExpExpr returns Expr:
	PrefixExpr (=>({BinaryExpr.left=current} op=('^')) right=PrefixExpr)*
;

PrefixExpr returns Expr:
	{UnaryExpr} op=('-' | 'not') expr=PrefixExpr
|	AtomicExpr
;

AtomicExpr returns Expr:
//  Need to figure out how to reference difference types of IDs, including cross references
//  to port names, state variables, etc.
//  Alternatively can the grammar be parameterized by the kinds of IDs to be supported?
//  For example, invariants should only reference state variables.	
//	{IdExpr} id=[aadl2::NamedElement | QCREF]
//    {StateVarRef} 'var' stateVar=[StateVarDecl|ID] ('.' ref=OtherDataRef)?
//|   {PortRef} 'port' port=ContainmentPathElement
   {DataRefExpr} portOrSubcomponentOrStateVar=[ecore::EObject|ID] ('.' ref=OtherDataRef)? cs=CallSuffix?
| => ({EnumLitExpr} 'enum' '(') enumType=DataElement ',' value=[aadl2::StringLiteral|ID] ')'
| => ({RecordLitExpr} recordType=DataElement '{' args+=[aadl2::NamedElement|ID] '=') argExpr+=Expr (';' args+=[aadl2::NamedElement|ID] '=' argExpr+=Expr)* '}'
|	{IntLit} value=INTEGER_LIT  // use int lit syntax from AADL properties file
|   {RealLitExpr} val=REAL_LIT
|   {BoolLitExpr} val=BooleanLiteral
|   {FloorCast} 'floor' '(' expr=Expr ')'
|   {RealCast}  'real' '(' expr=Expr ')'
//|   ID CallSuffix
|   '(' Expr ')'
;

OtherDataRef:
	(
		(
			namedElement=[aadl2::NamedElement|ID]
//	 		(arrayRange+=ArrayRange)*
		) 
		('.' path=OtherDataRef)?
//	 | 	 'annex' namedElement=[aadl2::NamedElement|ID]
	)
;

DoubleDotRef:
	elm=[aadl2::NamedElement|QCREF]
;

DataElement returns DataElement:
	dataElement = [aadl2::DataSubcomponentType|QCREF]
;

SubcomponentElement returns SubcomponentElement:
	subcomponent = [aadl2::Subcomponent|ID]
;

//FeatureElement returns FeatureElement:
//	feature=[aadl2::NamedElement|ID]
//;

SlangExpr
	: terms+=SlangAccess ( 
	  ( OP terms+=SlangAccess )* 
	  | '?' then=SlangExpr ':' els=SlangExpr
	  )
	| ( '\\all' | '\\some' | '∀' | '∃' ) var+=SlangQuantVar ( ',' var+=SlangQuantVar )* '=>' body=SlangExpr
	| OP SlangAccess
	;
	
SlangQuantVar: ID ':' val=SlangExpr ( ( '..' | '..<' ) upperBound=SlangExpr )? ;
	
SlangAccess: t=SlangTerm suf=AccessSuffix* ;

AccessSuffix: '.' ID CallSuffix? ;

SlangTerm
    : ID
	| '(' tuple+=SlangExpr ( ',' tuple+=SlangExpr )*  ')'
//	| 'for' forRange ( ',' forRange )*  'yield' ( SlangBlock |  '(' SlangExpr ')' )
//	| '{'
//	   ( params '=>' SlangExpr '}'
//	   | stmt* ret? '}'
//	   )
	;
	
SlangRet: 'return' SlangExpr? ;

CallSuffix
	: TypeArgs args=CallArgs?
	| args=CallArgs
	;
	
CallArgs: '(' ( f+=IdExp ( ',' f+=IdExp )* )? ')' ;
	
IdExp: l=Expr ( ':=' r=Expr )? ;

		
Type
	: BaseType ( '=>' BaseType )*
	| 'mut' BaseType ( '=>' BaseType )+
	;
	
BaseType
	: QCREF TypeArgs?
	| '(' ( Type ( ',' Type )* )? ')'
	;

TypeArgs: '[' Type ( ',' Type )* ']' ;

Functions:
	'functions' (specs+=FuncSpec)+
;

FuncSpec: DefDef ';';

Params: '(' Param ( ',' Param )? ')' ;
	
Param: 'var'? ID ':' ( '=>' )? Type '*'? ;

DefDef: DefMods? DefExt? name=DefID TypeParams? args=DefParams? ':' Type contract=DefContract? ':=' body=Expr ;

DefMods: 'strict' | 'memoize' | 'mut' | 'spec' ;

DefExt: '(' ID ':' Type ')' ;
	
DefID: ID | OP ;

DefParams: '(' params+=DefParam ( ',' params+=DefParam )? ')' ;
	
DefParam: name=ID ':' ( '=>' )? typeName=[aadl2::DataSubcomponentType|QCREF] '*'? ;

DefContract
	: {DefContract} 'spec'
	  ( rea=Reads? req=Requires? mod=Modifies? ens=Ensures?
	  | dcc+=DefContractCase+ rea=Reads? mod=Modifies?
	  )
	;

DefContractCase: {DefContractCase} 'case' STRING r=Requires? e=Ensures? ;

TypeParams: '[' TypeParam (  ',' TypeParam )* ']' ;

TypeParam: 'mut'? ID ;

Reads: 'reads' e+=Expr ( ',' e+=Expr )* ;

Requires: 'requires' e+=Expr ( ',' e+=Expr )* ;

Modifies: 'modifies' e+=Expr ( ',' e+=Expr )* ;

Ensures: 'ensures' e+=Expr ( ',' e+=Expr )* ;

terminal OP: ( OPSYM+ | '\\' IDF ) ;

terminal fragment IDF: ( LETTER | '_' ) ( LETTER | DIGIT )* ;

terminal fragment LETTER: ('a'..'z' | 'A'..'Z');

terminal fragment OPSYM
	: '+' | '-' | '*' | '/' | '%' | '=' | '<' | '>' | '!' | '&' | '^' | '|' | '~'
	| ( '\u2200' .. '\u22FF' ) // https://en.wikipedia.org/wiki/Mathematical_Operators
	| ( '\u2A00' .. '\u2AFF' ) // https://en.wikipedia.org/wiki/Supplemental_Mathematical_Operators
	| ( '\u27C0' .. '\u27EF' ) // https://en.wikipedia.org/wiki/Miscellaneous_Mathematical_Symbols-A
	| ( '\u2980' .. '\u29FF' ) // https://en.wikipedia.org/wiki/Miscellaneous_Mathematical_Symbols-B
	;
