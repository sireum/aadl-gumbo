grammar org.sireum.aadl.gumbo.Gumbo with org.osate.xtext.aadl2.properties.Properties

generate gumbo "http://www.sireum.org/aadl/gumbo/Gumbo"

import "http://aadl.info/AADL/2.0" as aadl2

import "http://www.eclipse.org/emf/2002/Ecore" as ecore


AnnexLibrary returns aadl2::AnnexLibrary:
	GumboLibrary
;

AnnexSubclause returns aadl2::AnnexSubclause:
	GumboSubclause
;

GumboLibrary returns GumboLibrary:
	{GumboLibrary}
	'library' 'for' 'gumbo'
;

GumboSubclause returns GumboSubclause:
	{GumboSubclause}
//	specs+=SpecSection*
    specs=SpecSection
;

SpecSection:
//	ComputationalModel
//|	Flows
	(state = State)?
	(invariants = Invariants)?
	(integration = Integration)?
	(initialize = Initialize)?
	(compute = Compute)?
;

//ComputationalModel:
//	'computational_model' (
//		{PeriodicComputationalModel} 'periodic'
//	|	{HyperperiodComputationalModel} 'hyperperiod' 'with' 
//		(constraints+=[aadl2::NamedElement] ('<' constraints+=[aadl2::NamedElement])* )
//	)
//;

//Flows:
//	'flows' (flows+=Flow)+
//;
//
//Flow returns Flow:
//	=>	flowId=ID ':' 
//		srcPorts+=FeatureElement (',' srcPorts+=FeatureElement)* '-fun->'
//		dstPorts+=FeatureElement (',' dstPorts+=FeatureElement)* 
//;


//Contract:
//	'contracts' (specs+=SpecStatement)+
//;

State:
	'state' (decls += StateVarDecl)+
;

StateVarDecl:
 // ...plain declaration without cross referencing is given below	
 // id1 = ID ':' typeName = ID
 // ...single id per type
 (name = ID ':') typeName=[aadl2::DataSubcomponentType|QCREF] ';'
 // ...multiple ids per type -- leave this out for now until I figure out how to get cross-referencing right for an id list
 // ids+=ID (',' ids+=ID)* ':' typeName=[aadl2::DataSubcomponentType|QCREF] ';'
;

Invariants:
	'invariants' (specs+=InvSpec)+
;

InvSpec:
	'inv' displayName=STRING ':' expr=Expr ';'
;

Integration:
	'integration' (specs+=SpecStatement)+
;

Initialize:
	'initialize' (specs+=InitializeSpecStatement)+
;

InitializeSpecStatement:
  GuaranteeStatement   	
;

Compute:
	'compute' 
	  // for now, just set the grammar to have a collection of case statements.  
	  // Eventually allow arbitrary assume/guarantees around an aggregated case statement
	   (cases+=CaseStatementClause)+
;

CaseStatementClause:
	'case' displayName=STRING ':' 
	       // in case clauses, we must have both an assume clause and a guarantee clause
	       // but they don't have a display name (they will "inherit" the name from the case name).
	       assumeStatement = AnonAssumeStatement
	       guaranteeStatement = AnonGuaranteeStatement
;

SpecStatement:
    AssumeStatement
  | GuaranteeStatement   	
;


AssumeStatement: 
	'assume' displayName=STRING ':' expr=Expr ';'
;

AnonAssumeStatement:  
	'assume' expr=Expr ';'
;

GuaranteeStatement: 
	'guarantee' displayName=STRING ':' expr=Expr ';'
;

AnonGuaranteeStatement: 
	'guarantee' expr=Expr ';'
;


//SpecStatement:
//	{AssumeStatement} 'assume' ('for' forPort=[aadl2::NamedElement])? 
//		assumeTitle=STRING ':' pred=PREDICATE ('tracesTo' '<' tracesTo=ID '>')?  
//|	{GuaranteeStatement} 'guarantee' guaranteeTitle=STRING ':' expr=Expr
//;

PREDICATE: // TODO 
	ID
;

Expr:
	ImpliesExpr
;

ImpliesExpr returns Expr:
	EquivExpr (=>({BinaryExpr.left=current} ('=>'|'implies')) right=ImpliesExpr)?
;

EquivExpr returns Expr:
	OrExpr (=> ({BinaryExpr.left=current} op='<=>') right=OrExpr)?;

OrExpr returns Expr:
	AndExpr (=>({BinaryExpr.left=current} (op='or'|op='orelse')) right=AndExpr)*
;

AndExpr returns Expr:
	RelationalExpr (=>({BinaryExpr.left=current} (op='and'|op='andthen')) right=RelationalExpr)*
;


RelationalOp:
	'<' | '<=' | '>' | '>=' | '=' | '<>'
;
 
RelationalExpr returns Expr:
	AddSubExpr (=>({BinaryExpr.left=current} op=RelationalOp) right=AddSubExpr)?
;

AddSubExpr returns Expr:
	MultDivModExpr (=>({BinaryExpr.left=current} op=('+' | '-')) right=MultDivModExpr)*
;

MultDivModExpr returns Expr:
	ExpExpr (=>({BinaryExpr.left=current} op=('*' | '/' | '%')) right=ExpExpr)*	
;

ExpExpr returns Expr:
	PrefixExpr (=>({BinaryExpr.left=current} op=('^')) right=PrefixExpr)*
;

PrefixExpr returns Expr:
	{UnaryExpr} op=('-' | 'not') expr=PrefixExpr
|	AtomicExpr
;

AtomicExpr returns Expr:
//  Need to figure out how to reference difference types of IDs, including cross references
//  to port names, state variables, etc.
//  Alternatively can the grammar be parameterized by the kinds of IDs to be supported?
//  For example, invariants should only reference state variables.	
//	{IdExpr} id=[aadl2::NamedElement | QCREF]
    {StateVarRef} 'var' stateVar=[StateVarDecl|ID]
|   {PortRef} 'port' port=FeatureElement
| => ({EnumLitExpr} 'enum' '(') enumType=[aadl2::Property|QCREF] ',' value=[aadl2::EnumerationLiteral|ID] ')'
| => ({RecordLitExpr} recordType=DataElement '{' args+=[aadl2::NamedElement|ID] '=') argExpr+=Expr (';' args+=[aadl2::NamedElement|ID] '=' argExpr+=Expr)* '}'
|	{IntLit} value=INTEGER_LIT  // use int lit syntax from AADL properties file
|   {RealLitExpr} val=REAL_LIT
|   {BoolLitExpr} val=BooleanLiteral
|   {FloorCast} 'floor' '(' expr=Expr ')'
|   {RealCast}  'real' '(' expr=Expr ')'
|   '(' Expr ')'
;

DoubleDotRef:
	elm=[aadl2::NamedElement|QCREF]
;

DataElement returns DataElement:
	dataElement = [aadl2::DataSubcomponentType|QCREF]
;

SubcomponentElement returns SubcomponentElement:
	subcomponent = [aadl2::Subcomponent|ID]
;

FeatureElement returns FeatureElement:
	feature=[aadl2::NamedElement|ID]
;
		