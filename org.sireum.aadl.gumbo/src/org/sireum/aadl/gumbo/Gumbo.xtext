grammar org.sireum.aadl.gumbo.Gumbo with org.osate.xtext.aadl2.properties.Properties

generate gumbo "http://www.sireum.org/aadl/gumbo/Gumbo"

import "http://aadl.info/AADL/2.0" as aadl2

import "http://www.eclipse.org/emf/2002/Ecore" as ecore


AnnexLibrary returns aadl2::AnnexLibrary:
	GumboLibrary
;

AnnexSubclause returns aadl2::AnnexSubclause:
	GumboSubclause
;

GumboLibrary returns GumboLibrary:
	{GumboLibrary}
	'library' 'for' 'gumbo'
;

GumboSubclause returns GumboSubclause:
	{GumboSubclause}
//	specs+=SpecSection*
    specs=SpecSection
;

SpecSection:
//	ComputationalModel
//|	Flows
	(state = State)?
	(functions = Functions)?
	(invariants = Invariants)?
	(integration = Integration)?
	(initialize = Initialize)?
	(compute = Compute)?
;

//ComputationalModel:
//	'computational_model' (
//		{PeriodicComputationalModel} 'periodic'
//	|	{HyperperiodComputationalModel} 'hyperperiod' 'with' 
//		(constraints+=[aadl2::NamedElement] ('<' constraints+=[aadl2::NamedElement])* )
//	)
//;

//Flows:
//	'flows' (flows+=Flow)+
//;
//
//Flow returns Flow:
//	=>	flowId=ID ':' 
//		srcPorts+=FeatureElement (',' srcPorts+=FeatureElement)* '-fun->'
//		dstPorts+=FeatureElement (',' dstPorts+=FeatureElement)* 
//;


//Contract:
//	'contracts' (specs+=SpecStatement)+
//;

State:
	'state' (decls += StateVarDecl)+
;

StateVarDecl:
 // ...plain declaration without cross referencing is given below	
 // id1 = ID ':' typeName = ID
 // ...single id per type
 (name = ID ':') typeName=[aadl2::DataSubcomponentType|QCREF] ';'
 // ...multiple ids per type -- leave this out for now until I figure out how to get cross-referencing right for an id list
 // ids+=ID (',' ids+=ID)* ':' typeName=[aadl2::DataSubcomponentType|QCREF] ';'
;

Invariants:
	'invariants' (specs+=InvSpec)+
;

InvSpec:
	'inv' displayName=STRING ':' expr=Expr ';'
;

Integration:
	'integration' (specs+=SpecStatement)+
;

Initialize:
	'initialize' (specs+=InitializeSpecStatement)+
;

InitializeSpecStatement:
  GuaranteeStatement   	
;

Compute:
	'compute' 
	  // for now, just set the grammar to have a collection of case statements.  
	  // Eventually allow arbitrary assume/guarantees around an aggregated case statement
	   (cases+=CaseStatementClause)+
;

CaseStatementClause:
	'case' displayName=STRING ':' 
	       // in case clauses, we must have both an assume clause and a guarantee clause
	       // but they don't have a display name (they will "inherit" the name from the case name).
	       assumeStatement = AnonAssumeStatement
	       guaranteeStatement = AnonGuaranteeStatement
;

SpecStatement:
    AssumeStatement
  | GuaranteeStatement   	
;


AssumeStatement: 
	'assume' displayName=STRING ':' expr=Expr ';'
;

AnonAssumeStatement:  
	'assume' expr=Expr ';'
;

GuaranteeStatement: 
	'guarantee' displayName=STRING ':' expr=Expr ';'
;

AnonGuaranteeStatement: 
	'guarantee' expr=Expr ';'
;


//SpecStatement:
//	{AssumeStatement} 'assume' ('for' forPort=[aadl2::NamedElement])? 
//		assumeTitle=STRING ':' pred=PREDICATE ('tracesTo' '<' tracesTo=ID '>')?  
//|	{GuaranteeStatement} 'guarantee' guaranteeTitle=STRING ':' expr=Expr
//;

PREDICATE: // TODO 
	ID
;

//AtomicExpr returns Expr:
//  Need to figure out how to reference difference types of IDs, including cross references
//  to port names, state variables, etc.
//  Alternatively can the grammar be parameterized by the kinds of IDs to be supported?
//  For example, invariants should only reference state variables.	
//	{IdExpr} id=[aadl2::NamedElement | QCREF]
//    {StateVarRef} 'var' stateVar=[StateVarDecl|ID] ('.' ref=OtherDataRef)?
//|   {PortRef} 'port' port=ContainmentPathElement
//   {DataRefExpr} portOrSubcomponentOrStateVar=[ecore::EObject|ID] ('.' ref=OtherDataRef)? cs=CallSuffix?
//| => ({EnumLitExpr} 'enum' '(') enumType=DataElement ',' value=[aadl2::StringLiteral|ID] ')'
//| => ({RecordLitExpr} recordType=DataElement '{' args+=[aadl2::NamedElement|ID] '=') argExpr+=Expr (';' args+=[aadl2::NamedElement|ID] '=' argExpr+=Expr)* '}'
//|	{IntLit} value=INTEGER_LIT  // use int lit syntax from AADL properties file
//|   {RealLitExpr} val=REAL_LIT
//|   {BoolLitExpr} val=BooleanLiteral
//|   {FloorCast} 'floor' '(' expr=Expr ')'
//|   {RealCast}  'real' '(' expr=Expr ')'
//|   ID CallSuffix
//|   '(' Expr ')'
//;

OtherDataRef:
	(
		(
			namedElement=[aadl2::NamedElement|ID]
//	 		(arrayRange+=ArrayRange)*
		) 
		('.' path=OtherDataRef)?
//	 | 	 'annex' namedElement=[aadl2::NamedElement|ID]
	)
;

DoubleDotRef:
	elm=[aadl2::NamedElement|QCREF]
;

DataElement returns DataElement:
	dataElement = [aadl2::DataSubcomponentType|QCREF]
;

SubcomponentElement returns SubcomponentElement:
	subcomponent = [aadl2::Subcomponent|ID]
;

//FeatureElement returns FeatureElement:
//	feature=[aadl2::NamedElement|ID]
//;

Functions:
	'functions' (specs+=FuncSpec)+
;

FuncSpec: SlangDefDef ';';

SlangDefDeclDef: 'def' SlangDefMods? sde=SlangDefExt? name=SlangDefID typeParams=SlangTypeParams? params=SlangDefParams? ':' type=SlangType c=SlangDefContract? ( ':=' e=Expr )? ;

SlangDefDecl: 'def' SlangDefMods? sde=SlangDefExt? name=SlangDefID typeParams=SlangTypeParams? params=SlangDefParams? ':' type=SlangType c=SlangDefContract? ;
	
SlangDefDef: 'def' SlangDefMods? sde=SlangDefExt? name=SlangDefID typeParams=SlangTypeParams? params=SlangDefParams? ':' type=SlangType c=SlangDefContract? ':=' e=Expr ;

SlangDefMods: 'strict' | 'memoize' | 'mut' | 'spec' ;

SlangDefExt: '(' name=ID ':' typeName=SlangType ')' ;
	
SlangDefID: ID | Operator ;

SlangDefParams: '(' params+=SlangDefParam ( ',' params+=SlangDefParam )? ')' ;
	
SlangDefParam: name=ID ':' ( '=>' )? typeName=SlangType '*'? ;


SlangTypeParams: '[' SlangTypeParam (  ',' SlangTypeParam )* ']' ;

SlangTypeParam: 'mut'? ID ;

SlangDefContract
	: {SlangDefContract} 'spec'
	  ( rea=SlangReads? req=SlangRequires? mod=SlangModifies? ens=SlangEnsures?
	  | contracts+=SlangDefContractCase+ rea=SlangReads? mod=SlangModifies?
	  )
	;

SlangDefContractCase: {SlangDefContractCase} 'case' /*SLANG_*/STRING req=SlangRequires? ens=SlangEnsures? ;

SlangSuprs: '<:' superTypes+=SlangSupr ( ',' superTypes+=SlangSupr )* ;

SlangSupr: SlangName SlangTypeArgs? ;

SlangName: ID ( '.' ID )* ;

SlangExt: {SlangExt} 'extension' ID ( 'for' SlangName )?  '{' decl+=SlangDefDecl* '}' ;

SlangInvariant: 'invariant' exprs+=Expr ( ',' exprs+=Expr )* ;

SlangReads: 'reads' exprs+=Expr ( ',' exprs+=Expr )* ;

SlangRequires: 'requires' exprs+=Expr ( ',' exprs+=Expr )* ;

SlangModifies: 'modifies' exprs+=Expr ( ',' exprs+=Expr )* ;

SlangEnsures: 'ensures' exprs+=Expr ( ',' exprs+=Expr )* ;

SlangStmt
	: {SlangVarDef} d=SlangVarDef
	| {SlangIfStmt} 'if' cond=Expr b=SlangBlock e=SlangElse?
//	| {SlangWhileStmt} 'while' cond=Expr l=SlangLoopContract b=SlangBlock
//	| {SlangForStmt} 'for' range+=SlangForRange ( ','  range+=SlangForRange )* l=SlangLoopContract b=SlangBlock
	| {SlangMatchStmt} 'match' testExpr=Expr '{' c+=SlangCase* '}'
	| {SlangSpecStmt} 'spec' b=SlangBlock
	| {SlangAssumeStmt} 'assume' e=Expr /*SLANG_*/STRING?
	| {SlangAssertStmt} 'assert' e=Expr /*SLANG_*/STRING?
	| {SlangHaltStmt} 'halt' /*SLANG_*/STRING?
	| {SlangDoStmt} 'do' e=Expr
//	| {SlangIdStmt} ID 
//	  ( ':'
//	  | l+=SlangLHSSuffix* ( ( ':=' | DEFOP ) e=Expr )?
//	  )
	;
	
SlangElse
	: 'else'
		( 'if' cond=Expr b=SlangBlock e=SlangElse?
		| SlangBlock
		)
	;
	
SlangLoopContract: {SlangLoopContract} inv=SlangInvariant? mod=SlangModifies? ;

SlangLHSSuffix
	: {SlangFieldLookup} '.' ID
	| {SlangMethodCall} '(' ( exprs+=Expr ( ',' exprs+=Expr )* )? ')'
	;

SlangCase: 'case' pattern=SlangPattern ( 'if' e=Expr )? '=>' s+=SlangStmt* ;

SlangPattern
	: ID ( '(' patterns+=SlangTPattern ( ',' patterns+=SlangTPattern )* ')' )?
	| '(' patterns+=SlangTPattern ( ',' patterns+=SlangTPattern )* ')'
	;

SlangTPattern
	: ID ( '(' patterns+=SlangTPattern ( ',' patterns+=SlangTPattern )* ')' | ':' type=SlangType )?
	| '(' patterns+=SlangTPattern ( ',' patterns+=SlangTPattern )* ')'
	| '_' ( ':' type=SlangType )?
	;
	
SlangTypedVarDef: SlangVarMod SlangPattern ':' type=SlangType ':=' init=Expr ;

SlangVarDef: SlangVarMod SlangPattern ( ':' type=SlangType )? ':=' init=Expr ;

SlangVarDeclDef: {SlangVarDeclDef} SlangVarMod 'spec'? name=ID ':' typeName=SlangType ( ':=' init=Expr )? ;

SlangVarMod: 'val' | 'var' ;

Expr
	: term+=SlangAccess ( 
	  ( Operator term+=SlangAccess )* 
	  | '?' thenExpr=Expr ':' elseExpr=Expr
	  )
	| ( '\\all' | '\\some' | '∀' | '∃' ) qVar+=SlangQuantVar ( ',' qVar+=SlangQuantVar )* '=>' quantifiedExpr=Expr
	| Operator SlangAccess
	;
	
SlangQuantVar: ID ':' e=Expr ( ( '..' | '..<' ) upperBound=Expr )? ;

SlangBlock: {SlangBlock} '{' stmts+=SlangStmt* r=SlangRet? '}' ;
	
SlangAccess returns Expr: t=SlangTerm ;//suf+=SlangAccessSuffix* ;

//SlangAccessSuffix: {SlangAccessSuffix} '.' ID cs=SlangCallSuffix? ;

SlangTerm returns Expr
	: {SlangLitTerm} SlangLit
	| {SlangInterpTerm} i=SlangInterp
	| => ({EnumLitExpr} 'enum' '(') enumType=DataElement ',' value=[aadl2::StringLiteral|ID] ')'
	| => ({RecordLitExpr} recordType=DataElement '{' args+=[aadl2::NamedElement|ID] '=') argExpr+=Expr (';' args+=[aadl2::NamedElement|ID] '=' argExpr+=Expr)* '}'
	| {DataRefExpr} portOrSubcomponentOrStateVar=[ecore::EObject|ID] ('.' ref=OtherDataRef)? cs=SlangCallSuffix?
	| {SlangTupleTerm} '(' e+=Expr ( ',' e+=Expr )*  ')'
	| {SlangForTerm} 'for' r+=SlangForRange ( ',' r+=SlangForRange )*  'yield' ( b=SlangBlock |  '(' e=Expr ')' )
	| {SlangBlockTerm} '{'
	   ( (p=SlangParams '=>')? e=Expr '}'
	    | stmt+=SlangStmt* r=SlangRet? '}'
	   )
	;


SlangParams: '(' params+=SlangParam ( ',' params+=SlangParam )? ')' ;
	
SlangParam: 'var'? name=ID ':' ( '=>' )? typeName=SlangType '*'? ;

SlangForRange: ID ':' e=Expr ( ( '..' |  '..<' ) upper=Expr ( 'by' step=Expr )? )? ;

SlangRet: {SlangRet} 'return' e=Expr? ;

SlangCallSuffix: {SlangCallSuffix}
	ta=SlangTypeArgs ca=SlangCallArgs?
	| ca=SlangCallArgs
	;
	
SlangCallArgs: {SlangCallArgs} '(' ( arg+=SlangIDExp ( ',' arg+=SlangIDExp )* )? ')' ;
	
SlangIDExp: e+=Expr ( ':=' e+=Expr )? ;
		
SlangType
	: SlangBaseType// ( '=>' SlangBaseType )*
	//| 'mut' SlangBaseType ( '=>' SlangBaseType )+
	;
	
SlangBaseType returns SlangType
	: typeName=[aadl2::DataSubcomponentType|QCREF]//ID SlangTypeArgs?
	//| '(' ( SlangType ( ',' SlangType )* )? ')'
	;

SlangTypeArgs: '[' types+=SlangType ( ',' types+=SlangType )* ']' ;

SlangLit
	: 'true'
	| 'false'
	| INTEGER_LIT//INT
//	| HEX
//	| BIN
	| REAL_LIT//REAL
	| /*SLANG_*/STRING
//	| MSTRING
	;

SlangInterp	: {SlangInterp}
	  MSP
	| MSPB SlangMInterp
	;

SlangMInterp
	: '{' Expr '}' ( MSPM m=SlangMInterp | MSPE )
	;
	
//terminal SLANG_STRING: '"' ( ESC_SEQ | !( '\\' | '"' ) )* '"' ;

//terminal MSTRING: '"""' ( !'"'|  '"' !'"' | '""' !'"' )* ( '"""' | '""""' | '"""""' ) ;
//
terminal MSP: IDF '"""' MSPI* ( '"""' | '""""' | '"""""' ) ;

terminal MSPB: IDF '"""' MSPI* '$' ;

terminal MSPM: '$' MSPI* '$' ;

terminal MSPE: '$' MSPI* ( '"""' | '""""' | '"""""' ) ;

//terminal DEFOP: ':' OPSYM* '=' ;
//

Operator: OP | PlusMinus | STAR;

terminal OP: ( OPSYM+ | '\\' IDF ) ;
//
//terminal INT
//	: '0' IDF?
//	| '1'..'9' DIGIT* IDF_NOU?
//	;
//	
//terminal HEX: '0x' EXTENDED_DIGIT+ ( '.' IDF )? ;
//
//terminal BIN: '0b' ( '0' | '1' | '_' )+ ( '.' IDF )? ;

//terminal REAL
//	: DIGIT+ '.' DIGIT+ EXPONENT? REALIDF?
//	| '.' DIGIT+ EXPONENT? REALIDF?
//	| DIGIT+ EXPONENT REALIDF?
//	;

//terminal CHAR: '\'' ( ESC_SEQ | !('\''|'\\') ) '\'' ;

terminal fragment IDF: ( LETTER | '_' ) ( LETTER | DIGIT )* ;

//terminal fragment IDF_NOU: LETTER ( LETTER | DIGIT )* ;
//
//terminal fragment REALIDF: LETTER_NOE ( LETTER | DIGIT )* ;
//
terminal fragment MSPI: !( '"' | '$' ) | '$$' | '"' !'"' | '""' !'"' ;

terminal fragment LETTER: 'a'..'z' | 'A'..'Z';

//terminal fragment LETTER_NOE: 'a'..'d' | 'f'..'z' | 'A'..'D' | 'F'..'Z' ;

terminal fragment OPSYM
	: //'+' | '-' | '*' |
	 '/' | '%' | '=' | '<' | '>' | '!' | '&' | '^' | '|' | '~'
	| ( '\u2200' .. '\u22FF' ) // https://en.wikipedia.org/wiki/Mathematical_Operators
	| ( '\u2A00' .. '\u2AFF' ) // https://en.wikipedia.org/wiki/Supplemental_Mathematical_Operators
	| ( '\u27C0' .. '\u27EF' ) // https://en.wikipedia.org/wiki/Miscellaneous_Mathematical_Symbols-A
	| ( '\u2980' .. '\u29FF' ) // https://en.wikipedia.org/wiki/Miscellaneous_Mathematical_Symbols-B
	;
	
//terminal fragment ESC_SEQ: '\\' ( 'b' | 't' | 'n' | 'f' | 'r' | '\"' | '\'' | '\\' ) | UNICODE_ESC ;
	
//terminal fragment UNICODE_ESC: '\\' 'u' EXTENDED_DIGIT EXTENDED_DIGIT EXTENDED_DIGIT EXTENDED_DIGIT ;
